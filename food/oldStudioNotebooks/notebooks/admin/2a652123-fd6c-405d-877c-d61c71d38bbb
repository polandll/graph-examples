json_notebook_v1{"1":"9530473a-e20f-452f-895a-4422d9f78d70","10":"42f6654b-5330-46fc-ab1f-63d397253bd9","11":"DSE Graph QuickStart","12":{"1":1456254917,"2":845000000},"13":{"1":1461964491,"2":416000000},"14":false,"15":[{"1":"d7e56e02-decd-43e2-a84f-237623517f6e","10":4,"11":"**Welcome to the DataStax QuickStart Tutorial Notebook!** \n\nThis notebook is designed to show you some basics about DSE Graph and Gremlin. You will load some data and do some simple graph traversals (queries) that will get you started with graph databases.","12":"markdown","13":{"1":"0dd18459-6d0b-43d0-9a45-8a1afdb2818c","10":{"9":"<p><strong>Welcome to the DataStax QuickStart Tutorial Notebook!</strong></p>\n<p>This notebook is designed to show you some basics about DSE Graph and Gremlin. You will load some data and do some simple graph traversals (queries) that will get you started with graph databases.</p>\n"},"11":4,"12":false,"14":0},"15":5,"16":true,"17":true},{"1":"e34c6cc4-26d9-41c2-9041-3b873f98baab","10":4,"11":"Graph databases are useful for discovering simple and complex relationships between objects. Relationships are fundamental to how objects interact with one another and their environment. Graph databases are the perfect representation of the relationships between objects.\n\nGraph databases consist of two elements: \n- vertex\n-- A vertex is an object, such as a person, location, automobile, recipe, or anything else you can think of as nouns.\n- edge\n-- An edge defines the relationship between two vertices. A person can create software, or an author can write a book. Think verbs when you are defining edges.\n\nBoth vertices and edges can have properties; for this reason, DSE Graph is classified as a **property graph**. The properties for both vertices and edges are an important element of storing and querying information from a property graph.\n\nProperty graphs are typically quite large, although the nature of querying the graph will vary depending on whether the graph has large numbers of vertices, edges, or both vertices and edges. To get started with graph database concepts, a \"toy\" graph is used for simplicity. The example used here explores the world of food.\n\n![Recipe Toy Graph](http://docs.datastax.com/en/datastax_enterprise/5.0/datastax_enterprise/graph/images/recipe3.svg)\n\nElements are labelled to distinguish the type of vertices and edges in a graph database using _vertex labels_ and _edge labels_. A vertex labelled _author_ holds information about an author. An edge in the graph between an _author_ and a _book_ is labelled _authored_. Specifying appropriate labels is an important step in [graph data modeling](http://docs.datastax.com/en/datastax_enterprise/5.0/datastax_enterprise/graph/data_modeling/dataModelTOC.html).\n\nVertices and edges generally have properties. For instance, an _author_ vertex can have the properties _name_ and _gender_. Edges may also have properties. A _created_ edge can have a _year_ property that identifies when the adjoining _recipe_ vertex was created.\n\nInformation in a graph database can be retrieved using _graph traversals_. _Graph traversals_ \"walk\" a graph with a single or series of _traversal steps_ that can define a starting point for a traversal and filter the results to find the answers to queries about the graph data.\n\nIn order to run graph traversals to retrieve information, schema is created and data is inserted. The steps listed in this section will allow you to gain a rudimentary understanding of DSE Graph with a minimum amount of configuration and schema creation.","12":"markdown","13":{"1":"ac50f02b-8962-48c6-b3b1-e6e3fbffab10","10":{"9":"<p>Graph databases are useful for discovering simple and complex relationships between objects. Relationships are fundamental to how objects interact with one another and their environment. Graph databases are the perfect representation of the relationships between objects.</p>\n<p>Graph databases consist of two elements:</p>\n<ul>\n<li>vertex\n<br  />&ndash; A vertex is an object, such as a person, location, automobile, recipe, or anything else you can think of as nouns.</li>\n<li>edge\n<br  />&ndash; An edge defines the relationship between two vertices. A person can create software, or an author can write a book. Think verbs when you are defining edges.</li>\n</ul>\n<p>Both vertices and edges can have properties; for this reason, DSE Graph is classified as a <strong>property graph</strong>. The properties for both vertices and edges are an important element of storing and querying information from a property graph.</p>\n<p>Property graphs are typically quite large, although the nature of querying the graph will vary depending on whether the graph has large numbers of vertices, edges, or both vertices and edges. To get started with graph database concepts, a &ldquo;toy&rdquo; graph is used for simplicity. The example used here explores the world of food.</p>\n<p><img src=\"http://docs.datastax.com/en/datastax_enterprise/5.0/datastax_enterprise/graph/images/recipe3.svg\" alt=\"Recipe Toy Graph\" /></p>\n<p>Elements are labelled to distinguish the type of vertices and edges in a graph database using <em>vertex labels</em> and <em>edge labels</em>. A vertex labelled <em>author</em> holds information about an author. An edge in the graph between an <em>author</em> and a <em>book</em> is labelled <em>authored</em>. Specifying appropriate labels is an important step in <a href=\"http://docs.datastax.com/en/datastax_enterprise/5.0/datastax_enterprise/graph/data_modeling/dataModelTOC.html\">graph data modeling</a>.</p>\n<p>Vertices and edges generally have properties. For instance, an <em>author</em> vertex can have the properties <em>name</em> and <em>gender</em>. Edges may also have properties. A <em>created</em> edge can have a <em>year</em> property that identifies when the adjoining <em>recipe</em> vertex was created.</p>\n<p>Information in a graph database can be retrieved using <em>graph traversals</em>. <em>Graph traversals</em> &ldquo;walk&rdquo; a graph with a single or series of <em>traversal steps</em> that can define a starting point for a traversal and filter the results to find the answers to queries about the graph data.</p>\n<p>In order to run graph traversals to retrieve information, schema is created and data is inserted. The steps listed in this section will allow you to gain a rudimentary understanding of DSE Graph with a minimum amount of configuration and schema creation.</p>\n"},"11":4,"12":false,"14":0},"15":5,"16":true,"17":true,"18":{}},{"1":"da75b4fe-6468-40d0-a558-83032f08de9e","10":4,"11":"Install [DSE](http://docs.datastax.com/en/datastax_enterprise/5.0/datastax_enterprise/install/installTOC.html) and start it if you have not already installed it.","12":"markdown","13":{"1":"08f23bd2-d299-4b1b-8242-353e7b764c70","10":{"9":"<p>Install <a href=\"http://docs.datastax.com/en/datastax_enterprise/5.0/datastax_enterprise/install/installTOC.html\">DSE</a> and start it if you have not already installed it.</p>\n"},"11":4,"12":false},"16":true,"17":true},{"1":"1ba4dd9d-7327-4698-b59f-6f39c62d12ea","10":4,"11":"This notebook makes a connection to a graph named **quickstart**. A _graph_ is created along with a graph traversal _g_ that will allow graph traversals to be executed.\n\nThe _graph_ commands usually add vertices or edges to the database, or get other graph information. The _g_ commands generally do queries to obtain results.","12":"markdown","13":{"1":"4d7a7e2d-4182-4da2-91a0-6cd05030721d","10":{"9":"<p>This notebook makes a connection to a graph named <strong>quickstart</strong>. A <em>graph</em> is created along with a graph traversal <em>g</em> that will allow graph traversals to be executed.</p>\n<p>The <em>graph</em> commands usually add vertices or edges to the database, or get other graph information. The <em>g</em> commands generally do queries to obtain results.</p>\n"},"11":4,"12":false,"14":0},"15":5,"16":true,"17":true},{"1":"df0ae516-a7f8-4ea9-a33b-bbcf1e3b1bc6","10":4,"11":"Check the number of vertices that exist in the graph using the traversal step count(). There should currently be none, because we have not added data yet. A graph traversal _g_ is chained with _V()_ to get all vertices and _count()_ to get the number of vertices.\n\nNote: Be aware that _count()_ should NOT be run on large graphs! If multiple DSE nodes are configured, this traversal step intensively walks all partitions on all nodes in the cluster.","12":"markdown","13":{"1":"7f256361-0668-4802-bd98-3dc5d3cd9ecf","10":{"9":"<p>Check the number of vertices that exist in the graph using the traversal step count(). There should currently be none, because we have not added data yet. A graph traversal <em>g</em> is chained with <em>V()</em> to get all vertices and <em>count()</em> to get the number of vertices.</p>\n<p>Note: Be aware that <em>count()</em> should NOT be run on large graphs! If multiple DSE nodes are configured, this traversal step intensively walks all partitions on all nodes in the cluster.</p>\n"},"11":4,"12":false},"16":true,"17":true},{"1":"46389868-f2e7-4151-9e8f-d2f875e4f17c","11":"g.V().count()","12":"gremlin","16":true,"17":false},{"1":"119c57f9-9378-4ac5-85fd-e528bdf1f18c","10":4,"11":"A simple example is composed of two vertices, one author (Julia Child) and one book (The Art of French Cooking, Vol. 1) with an edge between them to identify that Julia Child authored that book. Without creating any schema, the three elements can be created as shown below. However, DSE Graph makes a best guess at the schema, as we'll talk about below.\n\nFirst, let's make a vertex for Julia Child. The vertex label is _author_, and two property key-value pairs are created for _name_ and _gender_. Note the use of label to designate the key for a key-value pair that sets the vertex label.\n\nRun the command and look at the results using the buttons to display the Raw, Table, and Graph views.","12":"markdown","13":{"1":"8de0c988-c6bd-424f-9c05-ce5593346455","10":{"9":"<p>A simple example is composed of two vertices, one author (Julia Child) and one book (The Art of French Cooking, Vol. 1) with an edge between them to identify that Julia Child authored that book. Without creating any schema, the three elements can be created as shown below. However, DSE Graph makes a best guess at the schema, as we'll talk about below.</p>\n<p>First, let's make a vertex for Julia Child. The vertex label is <em>author</em>, and two property key-value pairs are created for <em>name</em> and <em>gender</em>. Note the use of label to designate the key for a key-value pair that sets the vertex label.</p>\n<p>Run the command and look at the results using the buttons to display the Raw, Table, and Graph views.</p>\n"},"11":4,"12":false},"16":true,"17":true},{"1":"0b68e0c3-5381-4ef3-8a70-2ee0f3d11a4a","11":"juliaChild = graph.addVertex(label,'author', 'name','Julia Child', 'gender','F')","12":"gremlin","16":true,"17":false},{"1":"7ceebe3f-8b9f-485a-97ba-2258246b0ee2","10":4,"11":"Each view displays the same information: \n- an auto-generated id, consisting of a member_id, community_id and label\n-- The member_id and community_id are used for grouping vertices within the graph [(more information)](http://docs.datastax.com/en/datastax_enterprise/5.0/datastax_enterprise/graph/using/usingQueryAnatomy.html)\n- the vertex label\n- the properties, name and gender, and their values\n\nAs you will see in the next command, a property key can be reused for different types of information. While properties are \"global\" in the sense that they can be used with multiple vertex labels, it is important to understand that when specifying a property in a graph traversal, it is always used in conjunction with a vertex label.\n\nRun the next command to create a book vertex. Don't run any command twice, or you'll create a duplicate in the graph!\n","12":"markdown","13":{"1":"726b1d6c-c211-4ccb-ae2e-dbf263a21340","10":{"9":"<p>Each view displays the same information:</p>\n<ul>\n<li>an auto-generated id, consisting of a member_id, community_id and label\n<br  />&ndash; The member_id and community_id are used for grouping vertices within the graph <a href=\"http://docs.datastax.com/en/datastax_enterprise/5.0/datastax_enterprise/graph/using/usingQueryAnatomy.html\">(more information)</a></li>\n<li>the vertex label</li>\n<li>the properties, name and gender, and their values</li>\n</ul>\n<p>As you will see in the next command, a property key can be reused for different types of information. While properties are &ldquo;global&rdquo; in the sense that they can be used with multiple vertex labels, it is important to understand that when specifying a property in a graph traversal, it is always used in conjunction with a vertex label.</p>\n<p>Run the next command to create a book vertex. Don't run any command twice, or you'll create a duplicate in the graph!</p>\n"},"11":4,"12":false,"14":0},"15":5,"16":true,"17":true},{"1":"9ad10ba9-1ea0-4078-94d6-fe1096bd4837","11":"artOfFrenchCookingVolOne = graph.addVertex(label, 'book','name', 'The Art of French Cooking, Vol. 1', 'year', 1961)","12":"gremlin","16":true,"17":false},{"1":"d3d259c4-7998-4725-9ef7-b69bd366bfbe","10":4,"11":"As with the author vertex, you can see all the information about the book vertex created. In Graph view, use the Settings button (the gear) to change the display label for author by entering `Chef {{name}}`. Change the book display label with `{{label}}:{{name}}`.\n\nRun the next two commands. The first command creates the edge between the author and book vertices. The second command is a graph traversal that retrieves the two vertices and the edge that connects them. Use Graph view to see the relationship. Scroll over elements to display additional information.","12":"markdown","13":{"1":"60bfe754-d1bd-4e40-bade-885343493be1","10":{"9":"<p>As with the author vertex, you can see all the information about the book vertex created. In Graph view, use the Settings button (the gear) to change the display label for author by entering <code>Chef {{name}}</code>. Change the book display label with <code>{{label}}:{{name}}</code>.</p>\n<p>Run the next two commands. The first command creates the edge between the author and book vertices. The second command is a graph traversal that retrieves the two vertices and the edge that connects them. Use Graph view to see the relationship. Scroll over elements to display additional information.</p>\n"},"11":4,"12":false,"14":0},"15":5,"16":true,"17":true},{"1":"0265b3b5-3c4d-4a75-8fca-612ddb67a3cc","11":"juliaChild.addEdge('authored', artOfFrenchCookingVolOne)\ng.V()","12":"gremlin","16":true,"17":false},{"1":"79f92677-b95a-4ab1-b6e0-0210a99d9749","10":4,"11":"We now have data! Check that the data inserted for the author is correct by checking with a _has()_ step that uses the vertex label _author_ and the property _name = Julia Child_ to find the correct vertex. This graph traversal is a basic starting point for more complex traversals, because it narrows the search of the graph with specific information.\n\nUse the Table view to look at the results, as it is much more readable than the Raw view.","12":"markdown","13":{"1":"db5bdb21-50b7-4294-a90d-2775b8d78eaa","10":{"9":"<p>We now have data! Check that the data inserted for the author is correct by checking with a <em>has()</em> step that uses the vertex label <em>author</em> and the property <em>name = Julia Child</em> to find the correct vertex. This graph traversal is a basic starting point for more complex traversals, because it narrows the search of the graph with specific information.</p>\n<p>Use the Table view to look at the results, as it is much more readable than the Raw view.</p>\n"},"11":4,"12":false,"14":0},"15":5,"16":true,"17":true},{"1":"b3d2f98b-c3fc-4622-b2a2-935d5a7c67e3","11":"g.V().has('author','name','Julia Child')","12":"gremlin","16":true,"17":false},{"1":"cfed188f-a0a7-4a33-ae6b-93177ba525de","10":4,"11":"A _vertex label_ **author** specifies the type of vertex, and the _property keys_ **name** and **gender** and their values are displayed .The _id_ is also listed. The [Anatomy of a Graph Traversal](http://docs.datastax.com/en/datastax_enterprise/5.0/datastax_enterprise/graph/using/usingQueryAnatomy.html) explains the id components.\n\nAnother useful traversal is _valueMap()_ which prints the key-value listing of each property value for specified vertices.\n","12":"markdown","13":{"1":"22cc3347-8a9a-49d7-9592-0b3f8b366d79","10":{"9":"<p>A <em>vertex label</em> <strong>author</strong> specifies the type of vertex, and the <em>property keys</em> <strong>name</strong> and <strong>gender</strong> and their values are displayed .The <em>id</em> is also listed. The <a href=\"http://docs.datastax.com/en/datastax_enterprise/5.0/datastax_enterprise/graph/using/usingQueryAnatomy.html\">Anatomy of a Graph Traversal</a> explains the id components.</p>\n<p>Another useful traversal is <em>valueMap()</em> which prints the key-value listing of each property value for specified vertices.</p>\n"},"11":4,"12":false},"16":true,"17":true},{"1":"5c2103f5-f265-426f-82c1-b468eec1292a","11":"g.V().hasLabel('author').valueMap()","12":"gremlin","16":true,"17":false},{"1":"08dc1c49-7888-4846-aeff-faec9396bf47","10":4,"11":"If only the value of a particular property key is desired, the _values()_ traversal step can be used. This example below gets the _name_ of all vertices.","12":"markdown","13":{"1":"357d3864-d337-479c-94d7-f33985e0a404","10":{"9":"<p>If only the value of a particular property key is desired, the <em>values()</em> traversal step can be used. This example below gets the <em>name</em> of all vertices.</p>\n"},"11":4,"12":false,"14":0},"16":true,"17":true},{"1":"579d2894-377b-486e-ba21-ec54db533e99","11":"g.V().values('name')","12":"gremlin","16":true,"17":false},{"1":"f5b04231-26c5-460c-a3a5-b6206ffee64b","10":4,"11":"Edge information may also be retrieved. The next command filters all edges to find those with an _edge label_ **authored**. The edge information displays details about the incoming and outgoing vertices as well as edge parameters _id_, _label_, and _type_.","12":"markdown","13":{"1":"e8507088-169b-4e69-b145-8f45393f2652","10":{"9":"<p>Edge information may also be retrieved. The next command filters all edges to find those with an <em>edge label</em> <strong>authored</strong>. The edge information displays details about the incoming and outgoing vertices as well as edge parameters <em>id</em>, <em>label</em>, and <em>type</em>.</p>\n"},"11":4,"12":false,"14":0},"15":5,"16":true,"17":true},{"1":"3040b1cf-a13f-42b8-bf77-c76cb381df7d","11":"g.E().hasLabel('authored')","12":"gremlin","16":true,"17":false},{"1":"8b6c7d07-37da-4bad-8672-347806d56148","10":4,"11":"The traversal step _count()_ is useful for counting both the number of vertices and the number of edges. To count edges, use _E()_ rather than _V()_. You should have one edge.","12":"markdown","13":{"1":"713b703a-5b63-4492-9362-841c161171e9","10":{"9":"<p>The traversal step <em>count()</em> is useful for counting both the number of vertices and the number of edges. To count edges, use <em>E()</em> rather than <em>V()</em>. You should have one edge.</p>\n"},"11":4,"12":false,"14":0},"15":5,"16":true,"17":true},{"1":"3a061266-06fb-4271-a3db-492134313428","10":4,"11":"g.E().count()","12":"gremlin","13":{"1":"3997c691-a002-46e9-80d2-86d435e303ec","10":{"25":"LinkedList","1":[{"5":1}]},"11":9,"12":false,"14":36},"15":6,"16":true,"17":false,"18":{}},{"1":"bedd2d32-220b-4fdc-90c4-70c79f879229","10":4,"11":"Re-running the vertex count traversal done at the beginning of the notebook should now yield two vertices.","12":"markdown","13":{"1":"06ab4376-6453-4065-ba9b-e90d590fdaf1","10":{"9":"<p>Re-running the vertex count traversal done at the beginning of the notebook should now yield two vertices.</p>\n"},"11":4,"12":false,"14":0},"16":true,"17":true},{"1":"de38d784-c919-4f2c-951e-d67340607b3c","11":"g.V().count()","12":"gremlin","16":true,"17":false},{"1":"ae21223a-281c-457c-9b54-714a0f95f9c1","10":4,"11":"Before adding more data to the graph, let's stop and talk about schema. Schema is used to define the possible properties and their data types that will be used in the graph. These properties are then used in the definitions of vertex labels and edge labels. The last critical step in schema creation is index creation. Indexes play an important role in making graph traversals efficient and fast.\n\nMore information can be found in the documents about [creating schema](http://docs.datastax.com/en/datastax_enterprise/5.0/datastax_enterprise/graph/using/usingCreateSchemaStudio.html) and [creating indexes](http://docs.datastax.com/en/datastax_enterprise/5.0/datastax_enterprise/graph/using/usingIndexTOC.html).\n\nFirst, let's create schema for the property keys. In the next two cells, the first command clears the schema that was set when we created the first two vertices and edge. After the schema creation is completed, you enter data for those elements again in a longer script.\n\n**Note:** DSE Graph has two schema modes, Production and Development. In Production mode, all schema must be identified before data is entered. In Development mode, schema can be created after data is entered.\n\n","12":"markdown","13":{"1":"e047730f-bffe-4f02-ae6f-6320823d447f","10":{"9":"<p>Before adding more data to the graph, let's stop and talk about schema. Schema is used to define the possible properties and their data types that will be used in the graph. These properties are then used in the definitions of vertex labels and edge labels. The last critical step in schema creation is index creation. Indexes play an important role in making graph traversals efficient and fast.</p>\n<p>More information can be found in the documents about <a href=\"http://docs.datastax.com/en/datastax_enterprise/5.0/datastax_enterprise/graph/using/usingCreateSchemaStudio.html\">creating schema</a> and <a href=\"http://docs.datastax.com/en/datastax_enterprise/5.0/datastax_enterprise/graph/using/usingIndexTOC.html\">creating indexes</a>.</p>\n<p>First, let's create schema for the property keys. In the next two cells, the first command clears the schema that was set when we created the first two vertices and edge. After the schema creation is completed, you enter data for those elements again in a longer script.</p>\n<p><strong>Note:</strong> DSE Graph has two schema modes, Production and Development. In Production mode, all schema must be identified before data is entered. In Development mode, schema can be created after data is entered.</p>\n"},"11":4,"12":false},"16":true,"17":true},{"1":"521d2b0b-5b12-4176-acd8-1b05a52babc5","11":"schema.clear()  //clear the schema from the previous commands executed above in a separate cell","12":"gremlin","16":true,"17":false},{"1":"dd8ab422-e53c-430c-8ee4-14b7d2ca28ad","11":"// Property Keys \nschema.propertyKey('name').Text().ifNotExists().create()        // Check for previous creation of property key with ifNotExists() \nschema.propertyKey('gender').Text().create()\nschema.propertyKey('instructions').Text().create()\nschema.propertyKey('category').Text().create()\nschema.propertyKey('year').Int().create()\nschema.propertyKey('timestamp').Timestamp().create()\nschema.propertyKey('ISBN').Text().create()\nschema.propertyKey('calories').Int().create()\nschema.propertyKey('amount').Text().create()\nschema.propertyKey('stars').Int().create()\nschema.propertyKey('comment').Text().single().create()          // single() is optional, as it is the default\n// schema.propertyKey('nickname').Text().multiple().create()    // Example of a multiple property that can have several values\n// schema.propertyKey('country').Text().create()                        // Next 3 lines define two properties, then create a meta-property 'livedIn' on 'country'\n// schema.propertyKey('livedIn').Text().create()                        // A meta-property is a property of a property\n// schema.propertyKey('country').Text().properties('livedIn').create()  // EX: 'livedIn': '1999-2005' 'country': 'Belgium'","12":"gremlin","16":true,"17":false},{"1":"e8c70047-84c4-4a7d-a4d2-1735595e1b07","10":4,"11":"Each property must be defined with a [data type](http://docs.datastax.com/en/datastax_enterprise/5.0/datastax_enterprise/graph/reference/refDSEGraphDataTypes.html). DSE Graph data types are aligned with Cassandra data types.\n\nThe data types used here are _Text_, _Int_, and _Timestamp_. By default, properties have single cardinality, but may be defined with multiple cardinality. Multiple cardinality allows more than one value to be assigned to a property.\n\nIn addition, properties can have their own properties, or **meta-properties**. Meta-properties can only be nested one deep, and are useful for keying information to an individual property.\n\nNotice that property keys may be created with an additional method _ifNotExists()_ to prevent overwriting a definition that may already exist.\n\nAfter property keys are created, vertex labels and edge labels may be defined.\n\n","12":"markdown","13":{"1":"b302a179-e148-45c2-8eb4-845a5586aa1b","10":{"9":"<p>Each property must be defined with a <a href=\"http://docs.datastax.com/en/datastax_enterprise/5.0/datastax_enterprise/graph/reference/refDSEGraphDataTypes.html\">data type</a>. DSE Graph data types are aligned with Cassandra data types.</p>\n<p>The data types used here are <em>Text</em>, <em>Int</em>, and <em>Timestamp</em>. By default, properties have single cardinality, but may be defined with multiple cardinality. Multiple cardinality allows more than one value to be assigned to a property.</p>\n<p>In addition, properties can have their own properties, or <strong>meta-properties</strong>. Meta-properties can only be nested one deep, and are useful for keying information to an individual property.</p>\n<p>Notice that property keys may be created with an additional method <em>ifNotExists()</em> to prevent overwriting a definition that may already exist.</p>\n<p>After property keys are created, vertex labels and edge labels may be defined.</p>\n"},"11":4,"12":false},"16":true,"17":true},{"1":"61bfa472-d6d3-4545-a4fa-54473f245543","11":"// Vertex Labels\nschema.vertexLabel('author').ifNotExists().create()\nschema.vertexLabel('recipe').create()\n// schema.vertexLabel('recipe').properties('name','instructions').create()      // Example of creating vertex label with properties\n// schema.vertexLabel('recipe').properties('name','instructions').add()         // Example of adding properties to a previously created vertex label\nschema.vertexLabel('ingredient').create()\nschema.vertexLabel('book').create()\nschema.vertexLabel('meal').create()\nschema.vertexLabel('reviewer').create()\n// Example of custom vertex id:\n// schema.propertyKey('city_id').Int().create()\n// schema.propertyKey('sensor_id').Uuid().create()\n// schema().vertexLabel('FridgeSensor').partitionKey('city_id').clusteringKey('sensor_id').create()\n                \n// Edge Labels\nschema.edgeLabel('authored').ifNotExists().create()\nschema.edgeLabel('created').create()\nschema.edgeLabel('includes').create()\nschema.edgeLabel('includedIn').create()\nschema.edgeLabel('rated').connection('reviewer','recipe').create()","12":"gremlin","16":true,"17":false},{"1":"ebb9a814-fa7b-4e85-9cba-68c1e109e99e","10":4,"11":"The schema for vertex labels defines the label \"type\", and optionally defines the properties associated with the vertex label. There are two different methods for defining the association of the properties with vertex labels, either during creation, or by adding them after vertex label addition. The _ifNotExists()_ method can be used for any schema creation.\n\nVertex _ids_ are automatically generated, but [custom vertex ids](http://docs.datastax.com/en/datastax_enterprise/5.0/datastax_enterprise/graph/using/usingCreateCustomVertexId.html) may be created if necessary. This custom vertex id example is explained in further detail in the documentation, but note that _partition keys_ and _clustering keys_ may be defined.\n\nThe schema for edge labels defines the label \"type\", and optionally defines the two vertex labels that are connected by the edge label. The edge label _rated_ will be used for edges between adjacent vertices that have the vertex labels _reviewer_ and _recipe_.\n\nNext, create the schema for the indexes.\n","12":"markdown","13":{"1":"1082d114-bcd4-4ce9-97e8-36f796a274bb","10":{"9":"<p>The schema for vertex labels defines the label &ldquo;type&rdquo;, and optionally defines the properties associated with the vertex label. There are two different methods for defining the association of the properties with vertex labels, either during creation, or by adding them after vertex label addition. The <em>ifNotExists()</em> method can be used for any schema creation.</p>\n<p>Vertex <em>ids</em> are automatically generated, but <a href=\"http://docs.datastax.com/en/datastax_enterprise/5.0/datastax_enterprise/graph/using/usingCreateCustomVertexId.html\">custom vertex ids</a> may be created if necessary. This custom vertex id example is explained in further detail in the documentation, but note that <em>partition keys</em> and <em>clustering keys</em> may be defined.</p>\n<p>The schema for edge labels defines the label &ldquo;type&rdquo;, and optionally defines the two vertex labels that are connected by the edge label. The edge label <em>rated</em> will be used for edges between adjacent vertices that have the vertex labels <em>reviewer</em> and <em>recipe</em>.</p>\n<p>Next, create the schema for the indexes.</p>\n"},"11":4,"12":false,"14":0},"15":5,"16":true,"17":true},{"1":"68b499ca-aece-47bb-b689-77c7c9cda3cf","11":"// Vertex Indexes\n// Secondary\nschema.vertexLabel('author').index('byName').secondary().by('name').add()\n// Materialized\t  \t\t\nschema.vertexLabel('recipe').index('byRecipe').materialized().by('name').add()\nschema.vertexLabel('meal').index('byMeal').materialized().by('name').add()\nschema.vertexLabel('ingredient').index('byIngredient').materialized().by('name').add()\nschema.vertexLabel('reviewer').index('byReviewer').materialized().by('name').add()\n// Search\n// schema.vertexLabel('recipe').index('search').search().by('instructions').asText().add()\n// schema.vertexLabel('recipe').index('search').search().by('instructions').asString().add()\n// If more than one property key is search indexed\n// schema.vertexLabel('recipe').index('search').search().by('instructions').asText().by('category').asString().add()\n\n// Property index using meta-property 'livedIn': \nschema.vertexLabel('author').index('byLocation').property('country').by('livedIn').add()\n\n// Edge Index\nschema.vertexLabel('reviewer').index('ratedByStars').outE('rated').by('stars').add()","12":"gremlin","16":true,"17":false},{"1":"86045ed2-ff24-471e-86e4-55d5dcb95a10","10":4,"11":"[Indexing](http://docs.datastax.com/en/datastax_enterprise/5.0/datastax_enterprise/graph/using/usingIndexTOC.html) is a complex and highly important topic. Here, several types of indexes are created. Briefly, secondary and materialized indexes are two types of indexes that use Cassandra built-in indexing. Search indexes use DSE Search which is Solr-based. Only one search index per vertex label is allowed, but multiple properties may be included. Property indexes allow meta-properties indexed. Edge indexes allow properties on edges to be indexed.\n\nNote that indexes are added with _add()_ to previously created vertex labels. After running all the cells to create the schema, examine the schema with the following command.","12":"markdown","13":{"1":"bed6a377-9a06-4f79-8552-3e313d081368","10":{"9":"<p><a href=\"http://docs.datastax.com/en/datastax_enterprise/5.0/datastax_enterprise/graph/using/usingIndexTOC.html\">Indexing</a> is a complex and highly important topic. Here, several types of indexes are created. Briefly, secondary and materialized indexes are two types of indexes that use Cassandra built-in indexing. Search indexes use DSE Search which is Solr-based. Only one search index per vertex label is allowed, but multiple properties may be included. Property indexes allow meta-properties indexed. Edge indexes allow properties on edges to be indexed.</p>\n<p>Note that indexes are added with <em>add()</em> to previously created vertex labels. After running all the cells to create the schema, examine the schema with the following command.</p>\n"},"11":4,"12":false,"14":0},"15":5,"16":true,"17":true},{"1":"f84095e6-50bd-490f-8623-4d8fc3a82268","11":"schema.describe()","12":"gremlin","16":true,"17":false},{"1":"f299f165-4b71-4e96-920a-6f22fb71ddff","10":4,"11":"The _schema.describe()_ command will display schema that can be used to recreate the schema entered. If you enter data without creating schema, this command can be used to verify the data types set for each property.\n\nCurrently, in DSE Graph, schema once created cannot be modified. Additional properties, vertex labels, edge labels, and indexes may be created, but the data type of a property, for instance, cannot be changed. While entering data without schema creation is handy while developing and learning, it is strongly recommended against for actual applications. As a reminder, Production mode disallows schema creation once data is loaded.","12":"markdown","13":{"1":"dbc04545-9a18-4222-8e81-c72bc32bf55e","10":{"9":"<p>The <em>schema.describe()</em> command will display schema that can be used to recreate the schema entered. If you enter data without creating schema, this command can be used to verify the data types set for each property.</p>\n<p>Currently, in DSE Graph, schema once created cannot be modified. Additional properties, vertex labels, edge labels, and indexes may be created, but the data type of a property, for instance, cannot be changed. While entering data without schema creation is handy while developing and learning, it is strongly recommended against for actual applications. As a reminder, Production mode disallows schema creation once data is loaded.</p>\n"},"11":4,"12":false,"14":0},"15":5,"16":true,"17":true},{"1":"74fcef99-bd7b-4963-ae47-4d694d7f6f2e","10":4,"11":"Should you wish to find only the schema for a particular type of item in the _describe()_ listing, additional steps may be used to split the output per newline and grep for a string as shown for the vertexLabel. Gremlin as shown in this notebook uses Groovy, so any Groovy commands may be used to manipulate graph traversals.","12":"markdown","13":{"1":"2b038f9b-3d0f-49b4-ba1e-70e35f39dc66","10":{"9":"<p>Should you wish to find only the schema for a particular type of item in the <em>describe()</em> listing, additional steps may be used to split the output per newline and grep for a string as shown for the vertexLabel. Gremlin as shown in this notebook uses Groovy, so any Groovy commands may be used to manipulate graph traversals.</p>\n"},"11":4,"12":false,"14":0},"16":true,"17":true},{"1":"1eb832b5-fa19-43fb-a2e0-f9c3195dfd8b","11":"schema.describe().split('\\n').grep(~/.*vertexLabel.*/)","12":"gremlin","16":true,"17":false},{"1":"6c1fa105-40c7-4b13-8cd4-acec2029e727","10":4,"11":"Now that schema is created, add more vertices and edges using the following script. To explore more connections in the recipe data model, more vertices and edges are input into the graph. A script, generateRecipe.groovy, is entered and then executed by the remote Gremlin server.\n\nNote the first command, _g.V().drop().iterate()_; this command can be used to drop all vertex and edge data from the graph before reading in new data. Be sure to select the Graph view after running the script.","12":"markdown","13":{"1":"849665ed-99d6-4110-83ab-0c49762f1bb7","10":{"9":"<p>Now that schema is created, add more vertices and edges using the following script. To explore more connections in the recipe data model, more vertices and edges are input into the graph. A script, generateRecipe.groovy, is entered and then executed by the remote Gremlin server.</p>\n<p>Note the first command, <em>g.V().drop().iterate()</em>; this command can be used to drop all vertex and edge data from the graph before reading in new data. Be sure to select the Graph view after running the script.</p>\n"},"11":4,"12":false,"14":0},"15":5,"16":true,"17":true},{"1":"301ea5ad-01d8-4b38-ba6a-046049a175c2","11":"// Generates all Recipe Toy Graph vertices and edges except Reviews\n\n// Add all vertices and edges for Recipe\ng.V().drop().iterate()\n\n// author vertices\njuliaChild = graph.addVertex(label, 'author', 'name','Julia Child', 'gender', 'F')\nsimoneBeck = graph.addVertex(label, 'author', 'name', 'Simone Beck', 'gender', 'F')\nlouisetteBertholie = graph.addVertex(label, 'author', 'name', 'Louisette Bertholie', 'gender', 'F')\npatriciaSimon = graph.addVertex(label, 'author', 'name', 'Patricia Simon', 'gender', 'F')\naliceWaters = graph.addVertex(label, 'author', 'name', 'Alice Waters', 'gender', 'F')\npatriciaCurtan = graph.addVertex(label, 'author', 'name', 'Patricia Curtan', 'gender', 'F')\nkelsieKerr = graph.addVertex(label, 'author', 'name', 'Kelsie Kerr', 'gender', 'F')\nfritzStreiff = graph.addVertex(label, 'author', 'name', 'Fritz Streiff', 'gender', 'M')\nemerilLagasse = graph.addVertex(label, 'author', 'name', 'Emeril Lagasse', 'gender', 'M')\njamesBeard = graph.addVertex(label, 'author', 'name', 'James Beard', 'gender', 'M')\n\n// book vertices\nartOfFrenchCookingVolOne = graph.addVertex(label, 'book', 'name', 'The Art of French Cooking, Vol. 1', 'year', 1961)\nsimcasCuisine = graph.addVertex(label, 'book', 'name', \"Simca's Cuisine: 100 Classic French Recipes for Every Occasion\", 'year', 1972, 'ISBN', '0-394-40152-2')\nfrenchChefCookbook = graph.addVertex(label, 'book', 'name','The French Chef Cookbook', 'year', 1968, 'ISBN', '0-394-40135-2')\nartOfSimpleFood = graph.addVertex(label, 'book', 'name', 'The Art of Simple Food: Notes, Lessons, and Recipes from a Delicious Revolution', 'year', 2007, 'ISBN', '0-307-33679-4')\n\n// recipe vertices\nbeefBourguignon = graph.addVertex(label, 'recipe', 'name', 'Beef Bourguignon', 'instructions', 'Braise the beef. Saute the onions and carrots. Add wine and cook in a dutch oven at 425 degrees for 1 hour.')\nratatouille = graph.addVertex(label, 'recipe', 'name', 'Rataouille', 'instructions', 'Peel and cut the egglant. Make sure you cut eggplant into lengthwise slices that are about 1-inch wmyIde, 3-inches long, and 3/8-inch thick')\nsaladeNicoise = graph.addVertex(label, 'recipe', 'name', 'Salade Nicoise', 'instructions', 'Take a salad bowl or platter and line it with lettuce leaves, shortly before serving. Drizzle some olive oil on the leaves and dust them with salt.')\nwildMushroomStroganoff = graph.addVertex(label, 'recipe', 'name', 'Wild Mushroom Stroganoff', 'instructions', 'Cook the egg noodles according to the package directions and keep warm. Heat 1 1/2 tablespoons of the oliveoil in a large saute pan over medium-high heat.')\nspicyMeatloaf = graph.addVertex(label, 'recipe', 'name', 'Spicy Meatloaf', 'instructions', 'Preheat the oven to 375 degrees F. Cook bacon in a large skillet over medium heat until very crisp and fat has rendered, 8-10 minutes.')\noystersRockefeller = graph.addVertex(label, 'recipe', 'name', 'Oysters Rockefeller', 'instructions', 'Saute the shallots, celery, herbs, and seasonings in 3 tablespoons of the butter for 3 minutes. Add the watercress and let it wilt.')\ncarrotSoup = graph.addVertex(label, 'recipe', 'name', 'Carrot Soup', 'instructions', 'In a heavy-bottomed pot, melt the butter. When it starts to foam, add the onions and thyme and cook over medium-low heat until tender, about 10 minutes.')\nroastPorkLoin = graph.addVertex(label, 'recipe', 'name', 'Roast Pork Loin', 'instructions', 'The day before, separate the meat from the ribs, stopping about 1 inch before the end of the bones. Season the pork liberally insmyIde and out with salt and pepper and refrigerate overnight.')\n\n// ingredients vertices\nbeef = graph.addVertex(label, 'ingredient', 'name', 'beef')\nonion = graph.addVertex(label, 'ingredient', 'name', 'onion')\nmashedGarlic = graph.addVertex(label, 'ingredient', 'name', 'mashed garlic')\nbutter = graph.addVertex(label, 'ingredient', 'name', 'butter')\ntomatoPaste = graph.addVertex(label, 'ingredient', 'name', 'tomato paste')\neggplant = graph.addVertex(label, 'ingredient', 'name', 'eggplant')\nzucchini = graph.addVertex(label, 'ingredient', 'name', 'zucchini')\noliveOil = graph.addVertex(label, 'ingredient', 'name', 'olive oil')\nyellowOnion = graph.addVertex(label, 'ingredient', 'name', 'yellow onion')\ngreenBean = graph.addVertex(label, 'ingredient', 'name', 'green beans')\ntuna = graph.addVertex(label, 'ingredient', 'name', 'tuna')\ntomato = graph.addVertex(label, 'ingredient', 'name', 'tomato')\nhardBoiledEgg = graph.addVertex(label, 'ingredient', 'name', 'hard-boiled egg')\neggNoodles = graph.addVertex(label, 'ingredient', 'name', 'egg noodles')\nmushroom = graph.addVertex(label, 'ingredient', 'name', 'mushrooms')\nbacon = graph.addVertex(label, 'ingredient', 'name', 'bacon')\ncelery = graph.addVertex(label, 'ingredient', 'name', 'celery')\ngreenBellPepper = graph.addVertex(label, 'ingredient', 'name', 'green bell pepper')\ngroundBeef = graph.addVertex(label, 'ingredient', 'name', 'ground beef')\nporkSausage = graph.addVertex(label, 'ingredient', 'name', 'pork sausage')\nshallot = graph.addVertex(label, 'ingredient', 'name', 'shallots')\nchervil = graph.addVertex(label, 'ingredient', 'name', 'chervil')\nfennel = graph.addVertex(label, 'ingredient', 'name', 'fennel')\nparsley = graph.addVertex(label, 'ingredient', 'name', 'parsley')\noyster = graph.addVertex(label, 'ingredient', 'name', 'oyster')\npernod = graph.addVertex(label, 'ingredient', 'name', 'Pernod')\nthyme = graph.addVertex(label, 'ingredient', 'name', 'thyme')\ncarrot = graph.addVertex(label, 'ingredient', 'name', 'carrots')\nchickenBroth = graph.addVertex(label, 'ingredient', 'name', 'chicken broth')\nporkLoin = graph.addVertex(label, 'ingredient', 'name', 'pork loin')\nredWine = graph.addVertex(label, 'ingredient', 'name', 'red wine')\n\n// meal vertices\nSaturdayFeast = graph.addVertex(label, 'meal', 'name', 'Saturday Feast', 'timestamp', Instant.parse('2015-11-30T00:00:00.00Z'), 'calories', 1000)\nEverydayDinner = graph.addVertex(label, 'meal', 'name', 'EverydayDinner', 'timestamp', Instant.parse('2016-01-14T00:00:00.00Z'), 'calories', 600)\nJuliaDinner = graph.addVertex(label, 'meal', 'name', 'JuliaDinner', 'timestamp', Instant.parse('2016-01-14T00:00:00.00Z'), 'calories', 900)\n\n// author-book edges\njuliaChild.addEdge('authored', artOfFrenchCookingVolOne)\nsimoneBeck.addEdge('authored', artOfFrenchCookingVolOne)\nlouisetteBertholie.addEdge('authored', artOfFrenchCookingVolOne)\nsimoneBeck.addEdge('authored', simcasCuisine)\npatriciaSimon.addEdge('authored', simcasCuisine)\njuliaChild.addEdge('authored', frenchChefCookbook)\naliceWaters.addEdge('authored', artOfSimpleFood)\npatriciaCurtan.addEdge('authored', artOfSimpleFood)\nkelsieKerr.addEdge('authored', artOfSimpleFood)\nfritzStreiff.addEdge('authored', artOfSimpleFood)\n\n// author - recipe edges\njuliaChild.addEdge('created', beefBourguignon, 'year', 1961)\njuliaChild.addEdge('created', ratatouille, 'year', 1965)\njuliaChild.addEdge('created', saladeNicoise, 'year', 1962)\nemerilLagasse.addEdge('created', wildMushroomStroganoff, 'year', 2003)\nemerilLagasse.addEdge('created', spicyMeatloaf, 'year', 2000)\naliceWaters.addEdge('created', carrotSoup, 'year', 1995)\naliceWaters.addEdge('created', roastPorkLoin, 'year', 1996)\njamesBeard.addEdge('created', oystersRockefeller, 'year', 1970)\n\n// recipe - ingredient edges\nbeefBourguignon.addEdge('includes', beef, 'amount', '2 lbs')\nbeefBourguignon.addEdge('includes', onion, 'amount', '1 sliced')\nbeefBourguignon.addEdge('includes', mashedGarlic, 'amount', '2 cloves')\nbeefBourguignon.addEdge('includes', butter, 'amount', '3.5 Tbsp')\nbeefBourguignon.addEdge('includes', tomatoPaste, 'amount', '1 Tbsp')\nratatouille.addEdge('includes', eggplant, 'amount', '1 lb')\nratatouille.addEdge('includes', zucchini, 'amount', '1 lb')\nratatouille.addEdge('includes', mashedGarlic, 'amount', '2 cloves')\nratatouille.addEdge('includes', oliveOil, 'amount', '4-6 Tbsp')\nratatouille.addEdge('includes', yellowOnion, 'amount', '1 1/2 cups or 1/2 lb thinly sliced')\nsaladeNicoise.addEdge('includes', oliveOil, 'amount', '2-3 Tbsp')\nsaladeNicoise.addEdge('includes', greenBean, 'amount', '1 1/2 lbs blanched, trimmed')\nsaladeNicoise.addEdge('includes', tuna, 'amount', '8-10 ozs oil-packed, drained and flaked')\nsaladeNicoise.addEdge('includes', tomato, 'amount', '3 or 4 red, peeled, quartered, cored, and seasoned')\nsaladeNicoise.addEdge('includes', hardBoiledEgg, 'amount', '8 halved lengthwise')\nwildMushroomStroganoff.addEdge('includes', eggNoodles, 'amount', '16 ozs wmyIde')\nwildMushroomStroganoff.addEdge('includes', mushroom, 'amount', '2 lbs wild or exotic, cleaned, stemmed, and sliced')\nwildMushroomStroganoff.addEdge('includes', yellowOnion, 'amount', '1 cup thinly sliced')\nspicyMeatloaf.addEdge('includes', bacon, 'amount', '3 ozs diced')\nspicyMeatloaf.addEdge('includes', onion, 'amount', '2 cups finely chopped')\nspicyMeatloaf.addEdge('includes', celery, 'amount', '2 cups finely chopped')\nspicyMeatloaf.addEdge('includes', greenBellPepper, 'amount', '1/4 cup finely chopped')\nspicyMeatloaf.addEdge('includes', porkSausage, 'amount', '3/4 lbs hot')\nspicyMeatloaf.addEdge('includes', groundBeef, 'amount', '1 1/2 lbs chuck')\noystersRockefeller.addEdge('includes', shallot, 'amount', '1/4 cup chopped')\noystersRockefeller.addEdge('includes', celery, 'amount', '1/4 cup chopped')\noystersRockefeller.addEdge('includes', chervil, 'amount', '1 tsp')\noystersRockefeller.addEdge('includes', fennel, 'amount', '1/3 cup chopped')\noystersRockefeller.addEdge('includes', parsley, 'amount', '1/3 cup chopped')\noystersRockefeller.addEdge('includes', oyster, 'amount', '2 dozen on the half shell')\noystersRockefeller.addEdge('includes', pernod, 'amount', '1/3 cup')\ncarrotSoup.addEdge('includes', butter, 'amount', '4 Tbsp')\ncarrotSoup.addEdge('includes', onion, 'amount', '2 medium sliced')\ncarrotSoup.addEdge('includes', thyme, 'amount', '1 sprig')\ncarrotSoup.addEdge('includes', carrot, 'amount', '2 1/2 lbs, peeled and sliced')\ncarrotSoup.addEdge('includes', chickenBroth, 'amount', '6 cups')\nroastPorkLoin.addEdge('includes', porkLoin, 'amount', '1 bone-in, 4-rib')\nroastPorkLoin.addEdge('includes', redWine, 'amount', '1/2 cup')\nroastPorkLoin.addEdge('includes', chickenBroth, 'amount', '1 cup')\n\n// book - recipe edges\nbeefBourguignon.addEdge('includedIn', artOfFrenchCookingVolOne)\nsaladeNicoise.addEdge('includedIn', artOfFrenchCookingVolOne)\ncarrotSoup.addEdge('includedIn', artOfSimpleFood)\n\n// meal - recipe edges\nbeefBourguignon.addEdge('includedIn', SaturdayFeast)\ncarrotSoup.addEdge('includedIn', SaturdayFeast)\noystersRockefeller.addEdge('includedIn', SaturdayFeast)\ncarrotSoup.addEdge('includedIn', EverydayDinner)\nroastPorkLoin.addEdge('includedIn', EverydayDinner)\nbeefBourguignon.addEdge('includedIn', JuliaDinner)\nsaladeNicoise.addEdge('includedIn', JuliaDinner)\n\n// meal - book edges\nEverydayDinner.addEdge('includedIn', artOfSimpleFood)\nSaturdayFeast.addEdge('includedIn', simcasCuisine)\nJuliaDinner.addEdge('includedIn', artOfFrenchCookingVolOne)\ng.V()\n","12":"gremlin","16":true,"17":false},{"1":"eb941a64-6dcb-435b-bd74-1f8fac0f9b51","10":4,"11":"There is one item to point out in the data loading. The property timestamp is of data type Timestamp. To read in a date for creation dates for the meals, a Java data type, _Instant_, is used to parse a date timestamp _Instant.parse('2015-11-30T00:00:00.00Z')_. The full definition for the date timestamp is required. \n\nUsing _g.V()_ at the end of the script will display all the vertices created. If a vertex count is run, there is now a higher count of 56 vertices.","12":"markdown","13":{"1":"ed8cfc31-88a3-48ee-a2b4-54a1f23c0802","10":{"9":"<p>There is one item to point out in the data loading. The property timestamp is of data type Timestamp. To read in a date for creation dates for the meals, a Java data type, <em>Instant</em>, is used to parse a date timestamp <em>Instant.parse('2015-11-30T00:00:00.00Z')</em>. The full definition for the date timestamp is required.</p>\n<p>Using <em>g.V()</em> at the end of the script will display all the vertices created. If a vertex count is run, there is now a higher count of 56 vertices.</p>\n"},"11":4,"12":false,"14":0},"15":5,"16":true,"17":true},{"1":"5c6f1e77-6feb-4ad4-937c-428b49fe927c","11":"g.V().count()","12":"gremlin","16":true,"17":false},{"1":"2dfcfcf1-d26f-436b-bafb-547e959e9d3d","10":4,"11":"A tool, graphloader, is also available for scripting data loading. See the [graphloader](http://docs.datastax.com/en/datastax_enterprise/5.0/datastax_enterprise/graph/dseGraphLoader/graphdseGraphLoaderTOC.html) documentation for information.","12":"markdown","13":{"1":"08316373-f956-4244-90b1-b7d33035b46e","10":{"9":"<p>A tool, graphloader, is also available for scripting data loading. See the <a href=\"http://docs.datastax.com/en/datastax_enterprise/5.0/datastax_enterprise/graph/dseGraphLoader/graphdseGraphLoaderTOC.html\">graphloader</a> documentation for information.</p>\n"},"11":4,"12":false,"14":0},"16":true,"17":true},{"1":"11a2af6e-8505-4ed9-b7cb-040f996e395a","10":4,"11":"\nExploring the graph with graph traversals can lead to interesting conclusions.\n\nWith several _author_ vertices in the graph, a specific _name_ must be given to find a particular vertex. This traversal gets the stored vertex information for the vertex that _has_ the _name_ of _Julia Child_. Note that the constraint that the vertex is an _author_ is also included in the _has()_ clause.","12":"markdown","13":{"1":"a1c77018-96cf-4346-a210-ccd78ed266e4","10":{"9":"<p>Exploring the graph with graph traversals can lead to interesting conclusions.</p>\n<p>With several <em>author</em> vertices in the graph, a specific <em>name</em> must be given to find a particular vertex. This traversal gets the stored vertex information for the vertex that <em>has</em> the <em>name</em> of <em>Julia Child</em>. Note that the constraint that the vertex is an <em>author</em> is also included in the <em>has()</em> clause.</p>\n"},"11":4,"12":false},"16":true,"17":true},{"1":"de696e99-6edf-4512-a198-dd820e9fb598","11":"g.V().has('author', 'name', 'Julia Child')","12":"gremlin","16":true,"17":false},{"1":"d119c333-bde8-4265-9bce-68d784950125","10":4,"11":"In the next traversal step, _has_ gets the vertex information filtered with _name = Julia Child_. The traversal step _outE()_ discovers the outgoing edges from that vertex with the _authored_ label. The edge information is the result shown the Raw view, while the Graph view shows the vertex and its incident edges and adjacent vertices.\n","12":"markdown","13":{"1":"4ef04564-a6e7-4374-bbc3-005cbe5b06ba","10":{"9":"<p>In the next traversal step, <em>has</em> gets the vertex information filtered with <em>name = Julia Child</em>. The traversal step <em>outE()</em> discovers the outgoing edges from that vertex with the <em>authored</em> label. The edge information is the result shown the Raw view, while the Graph view shows the vertex and its incident edges and adjacent vertices.</p>\n"},"11":4,"12":false},"16":true,"17":true},{"1":"1ca4f0a4-6dcb-4a4f-8558-a242a20257a5","11":"g.V().has('author', 'name', 'Julia Child').outE('authored')","12":"gremlin","16":true,"17":false},{"1":"45d8e46f-1633-4ac0-b00b-06ef354a5b4d","10":4,"11":"If instead, the query is seeking the books that all authors have written, the last example gets edges, but not the adjacent book vertices. Add a traversal step _inV()_ to find all the vertices that connect to the outgoing edges, then print the book titles of those vertices.\n\nNote how the chained traversal steps go from the vertices along outgoing edges to the adjacent vertices with _V().outE().inV()_. The outgoing edges are given a particular filter value, _authored_.","12":"markdown","13":{"1":"26ffa7ad-e67c-4c57-aa8a-fd00931622ba","10":{"9":"<p>If instead, the query is seeking the books that all authors have written, the last example gets edges, but not the adjacent book vertices. Add a traversal step <em>inV()</em> to find all the vertices that connect to the outgoing edges, then print the book titles of those vertices.</p>\n<p>Note how the chained traversal steps go from the vertices along outgoing edges to the adjacent vertices with <em>V().outE().inV()</em>. The outgoing edges are given a particular filter value, <em>authored</em>.</p>\n"},"11":4,"12":false,"14":0},"15":5,"16":true,"17":true},{"1":"d81959a3-892e-4496-bcdf-b561441b0ca5","11":"g.V().outE('authored').inV().values('name')","12":"gremlin","16":true,"17":false},{"1":"0d2aff04-9db2-407c-8506-cb91de589281","10":4,"11":"Notice that the book titles are duplicated in the resulting list, because a listing is returned for each author. If a book has three authors, three listings are returned. The traversal step _dedup()_ can eliminate the duplication.","12":"markdown","13":{"1":"28ad178e-7acd-4d6e-9df2-9e7e873bafb3","10":{"9":"<p>Notice that the book titles are duplicated in the resulting list, because a listing is returned for each author. If a book has three authors, three listings are returned. The traversal step <em>dedup()</em> can eliminate the duplication.</p>\n"},"11":4,"12":false,"14":0},"16":true,"17":true},{"1":"ab8a7138-bdb6-4e8a-bbb2-5b562d840a1d","11":"g.V().outE('authored').inV().values('name').dedup()","12":"gremlin","16":true,"17":false},{"1":"a8d3cf38-12fd-4e22-ab06-05ecddb7bdf7","10":4,"11":"Refine the traversal by reinserting the _has()_ step to filter for a particular author. Find all the books authored by _Julia Child_.","12":"markdown","13":{"1":"663ce331-4bd6-4295-8c49-7e4262e00abf","10":{"9":"<p>Refine the traversal by reinserting the <em>has()</em> step to filter for a particular author. Find all the books authored by <em>Julia Child</em>.</p>\n"},"11":4,"12":false},"16":true,"17":true},{"1":"add2829e-179b-4eb5-bceb-ecc07f4f81e8","11":"g.V().has('name','Julia Child').outE('authored').inV().values('name')","12":"gremlin","16":true,"17":false},{"1":"32f84aa3-f2d2-40cf-b0e0-4ab40a722a64","10":4,"11":"The last example and the next example accomplish the same result. However, the number of traversal steps and the type of traversal steps can affect performance. The traversal step _outE()_ should be used if the edges are explicitly required. In this example, the edges are traversed to get information about connected vertices, but the edge information is not important to the query, making the latter example more expedient.","12":"markdown","13":{"1":"006ff7b4-55bc-411c-bed9-b3638a57ba0e","10":{"9":"<p>The last example and the next example accomplish the same result. However, the number of traversal steps and the type of traversal steps can affect performance. The traversal step <em>outE()</em> should be used if the edges are explicitly required. In this example, the edges are traversed to get information about connected vertices, but the edge information is not important to the query, making the latter example more expedient.</p>\n"},"11":4,"12":false,"14":0},"16":true,"17":true},{"1":"954f97be-360a-4211-bf1f-8acc93fb748e","11":"g.V().has('name','Julia Child').out('authored').values('name')","12":"gremlin","16":true,"17":false},{"1":"7769e3ae-2ad4-4904-bcbc-4f093f3c9ce8","10":4,"11":"The traversal step _out()_ retrieves the connected book vertices based on the edge label _authored_ without retrieving the edge information. In a larger graph traversal, this subtle difference in the traversal can become a latency issue.\n\nAdditional traversal steps continue to fine-tune the results. Adding another chained _has_ traversal step finds only books authored by Julia Child that are published after 1967. This example also displays the use of the _gt_, or _greater than_ function.","12":"markdown","13":{"1":"4458b049-ed3f-4680-922b-eff96ea6fd3d","10":{"9":"<p>The traversal step <em>out()</em> retrieves the connected book vertices based on the edge label <em>authored</em> without retrieving the edge information. In a larger graph traversal, this subtle difference in the traversal can become a latency issue.</p>\n<p>Additional traversal steps continue to fine-tune the results. Adding another chained <em>has</em> traversal step finds only books authored by Julia Child that are published after 1967. This example also displays the use of the <em>gt</em>, or <em>greater than</em> function.</p>\n"},"11":4,"12":false,"14":0},"15":5,"16":true,"17":true},{"1":"5a2db90f-67f9-43b6-98d9-4aa93e652900","11":"g.V().has('name','Julia Child').out('authored').has('year', gt(1967)).values('name')","12":"gremlin","16":true,"17":false},{"1":"109ff139-57b7-4b4e-b803-26489f9f52a8","10":4,"11":"When developing or testing, oftentimes a check of the number of vertices with each vertex label can confirm that data has been read. To find the number of vertices by vertex label, use the traversal step _label()_ followed by the traversal step _groupCount()_. The step _groupCount()_ is useful for aggregating results from a previous step.","12":"markdown","13":{"1":"9e89e847-fbef-431e-ad45-8123b4306aea","10":{"9":"<p>When developing or testing, oftentimes a check of the number of vertices with each vertex label can confirm that data has been read. To find the number of vertices by vertex label, use the traversal step <em>label()</em> followed by the traversal step <em>groupCount()</em>. The step <em>groupCount()</em> is useful for aggregating results from a previous step.</p>\n"},"11":4,"12":false,"14":0},"15":5,"16":true,"17":true},{"1":"da925b73-785e-4db3-9561-77ec10c0b35f","11":"g.V().label().groupCount()","12":"gremlin","16":true,"17":false},{"1":"a88e3a2e-a008-4b7f-bf41-3acf7f7adddc","10":4,"11":"Write your data to an output file to save or exchange information. A Gryo file is a binary format file that can be used to reload data to DSE Graph. In this next command,graph I/O is used to write the entire graph to a file. Other file formats can be written by substituting _gryo()_ with _graphml()_ or _graphson()_. See the [documentation](http://docs.datastax.com/en/datastax_enterprise/5.0/datastax_enterprise/graph/using/graphUsingTOC.html) for more information.","12":"markdown","13":{"1":"34084ed3-bf3b-40d3-943c-b2579d81eafc","10":{"9":"<p>Write your data to an output file to save or exchange information. A Gryo file is a binary format file that can be used to reload data to DSE Graph. In this next command,graph I/O is used to write the entire graph to a file. Other file formats can be written by substituting <em>gryo()</em> with <em>graphml()</em> or <em>graphson()</em>. See the <a href=\"http://docs.datastax.com/en/datastax_enterprise/5.0/datastax_enterprise/graph/using/graphUsingTOC.html\">documentation</a> for more information.</p>\n"},"11":4,"12":false,"14":0},"15":5,"16":true,"17":true},{"1":"2d35d247-0eea-4238-a3c7-a75b49446c6e","10":4,"11":"graph.io(gryo()).writeGraph(\"/tmp/recipe.gryo\")","12":"gremlin","13":{"1":"7b2d1ace-b7db-426b-940a-e835ccebaacc","10":{"25":"LinkedList"},"11":8,"12":false,"14":161},"15":5,"16":true,"17":false},{"1":"cda99b93-6521-4f9a-b818-2267a2c46e7a","10":4,"11":"To load a Gryo file, use a read command.","12":"markdown","13":{"1":"71bfee5c-5024-4fd5-9ed1-5f70d7f091cc","10":{"9":"<p>To load a Gryo file, use a read command.</p>\n"},"11":4,"12":false,"14":0},"16":true,"17":true},{"1":"f324a1fe-9fd4-4e68-bc58-615f7eefca1c","10":4,"11":"graph.io(gryo()).readGraph(\"/tmp/recipe.gryo\")","12":"gremlin","13":{"1":"80533695-61f1-43ce-8520-26ea663ec306","10":{"25":"LinkedList"},"11":8,"12":false,"14":237},"15":5,"16":true,"17":false},{"1":"bf3da5df-bc49-45d7-93a1-f85fcf6da5bf","10":4,"11":"Further adventures in traversing can be found in [Creating queries using traversals] (http://docs.datastax.com/en/datastax_enterprise/5.0/datastax_enterprise/graph/getting_started/graphGettingStartedQueryTOC.html). If you want to explore various loading options, check out [DSE Graph Loader](http://docs.datastax.com/en/datastax_enterprise/5.0/datastax_enterprise/graph/dseGraphLoader/graphdseGraphLoaderTOC.html) or [Using DSE Graph](http://docs.datastax.com/en/datastax_enterprise/5.0/datastax_enterprise/graph/gusing/graphUsingTOC.html).","12":"markdown","13":{"1":"01347378-f34d-4e70-9450-26cd80da2646","10":{"9":"<p>Further adventures in traversing can be found in <a href=\"http://docs.datastax.com/en/datastax_enterprise/5.0/datastax_enterprise/graph/getting_started/graphGettingStartedQueryTOC.html\">Creating queries using traversals</a>. If you want to explore various loading options, check out <a href=\"http://docs.datastax.com/en/datastax_enterprise/5.0/datastax_enterprise/graph/dseGraphLoader/graphdseGraphLoaderTOC.html\">DSE Graph Loader</a> or <a href=\"http://docs.datastax.com/en/datastax_enterprise/5.0/datastax_enterprise/graph/gusing/graphUsingTOC.html\">Using DSE Graph</a>.</p>\n"},"11":4,"12":false,"14":0},"15":5,"16":true,"17":true}]}
